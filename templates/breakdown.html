{% extends "base.html" %}

{% block title %}Breakdown - STEWARD{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1>Budget Breakdown</h1>
        <p class="page-subtitle">Allocate and manage your budget across categories</p>
    </div>

    <div class="breakdown-container">
        <!-- Sticky Available Badge -->
        <div class="sticky-available-badge" id="stickyAvailableBadge">
            <span class="label">Available to allocate:</span>
            <span class="amount" id="stickyAvailableAmount">$0.00</span>
        </div>
        
        <!-- Budget Summary -->
        <div class="card budget-summary" id="budgetSummary">
            <div class="budget-summary-header" onclick="toggleBudgetSummary()">
                <h2>Budget Summary</h2>
                <i class="fas fa-chevron-up collapse-icon"></i>
            </div>
            <div class="card-body">
                <div class="budget-stats">
                    <div class="budget-stat" id="available-stat">
                        <span class="stat-label">Available to Allocate:</span>
                        <span class="stat-value" id="availableToAllocate">$0.00</span>
                    </div>
                    <div class="budget-stat" id="allocated-stat">
                        <span class="stat-label">Total Allocated:</span>
                        <span class="stat-value" id="totalAllocated">$0.00</span>
                    </div>
                    <div class="budget-stat" id="spent-stat">
                        <span class="stat-label">Total Spent:</span>
                        <span class="stat-value" id="totalSpent">$0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Categories Grid -->
        <div class="categories-grid" id="categoriesGrid">
            <!-- Categories will be loaded here -->
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons-section">
            <button class="btn btn-secondary btn-large" onclick="showRecurringAllocationsModal()">
                <i class="fas fa-repeat"></i>
                Manage Recurring Allocations
            </button>
            <button class="btn btn-primary btn-large" onclick="showAddCategoryModal()">
                <i class="fas fa-plus"></i>
                Add New Category
            </button>
        </div>
    </div>
</div>

<!-- Recurring Allocations Modal -->
<div class="modal" id="recurringAllocationsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Manage Recurring Allocations</h2>
            <button class="close-btn" onclick="closeModal('recurringAllocationsModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="recurring-section">
                <div class="section-header">
                    <h3>Recurring Budget Allocations</h3>
                    <button class="btn btn-primary" onclick="showAddRecurringAllocationModal()">
                        <i class="fas fa-plus"></i>
                        Add Recurring Allocation
                    </button>
                </div>
                <div id="recurringAllocationsList" class="recurring-list">
                    <!-- Recurring allocations will be loaded here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Recurring Allocation Modal -->
<div class="modal" id="addRecurringAllocationModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add Recurring Allocation</h2>
            <button class="close-btn" onclick="closeModal('addRecurringAllocationModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addRecurringAllocationForm">
                <div class="form-group">
                    <label for="recurringSubcategory">Subcategory</label>
                    <select id="recurringSubcategory" name="subcategory_id" required>
                        <option value="">Select a subcategory</option>
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="recurringAllocationAmount">Allocation Amount</label>
                    <div class="input-group">
                        <span class="input-prefix" data-currency-symbol>$</span>
                        <input type="number" id="recurringAllocationAmount" name="allocated_amount" step="0.01" min="0.01" required>
                    </div>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Recurring Allocation</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addRecurringAllocationModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Recurring Allocation Modal -->
<div class="modal" id="editRecurringAllocationModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Recurring Allocation</h2>
            <button class="close-btn" onclick="closeModal('editRecurringAllocationModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editRecurringAllocationForm">
                <div class="form-group">
                    <label for="editRecurringAllocationAmount">Allocation Amount</label>
                    <div class="input-group">
                        <span class="input-prefix" data-currency-symbol>$</span>
                        <input type="number" id="editRecurringAllocationAmount" name="allocated_amount" step="0.01" min="0.01" required>
                    </div>
                </div>
                <input type="hidden" id="editRecurringAllocationId" name="allocation_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editRecurringAllocationModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Add Category Modal -->
<div class="modal" id="addCategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add New Category</h2>
            <button class="close-btn" onclick="closeModal('addCategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addCategoryForm">
                <div class="form-group">
                    <label for="categoryName">Category Name</label>
                    <input type="text" id="categoryName" name="name" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Category</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addCategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Add Subcategory Modal -->
<div class="modal" id="addSubcategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add New Subcategory</h2>
            <button class="close-btn" onclick="closeModal('addSubcategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addSubcategoryForm">
                <div class="form-group">
                    <label for="subcategoryName">Subcategory Name</label>
                    <input type="text" id="subcategoryName" name="name" required>
                </div>
                <input type="hidden" id="parentCategoryId" name="category_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Subcategory</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addSubcategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Category Modal -->
<div class="modal" id="editCategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Category</h2>
            <button class="close-btn" onclick="closeModal('editCategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editCategoryForm">
                <div class="form-group">
                    <label for="editCategoryName">Category Name</label>
                    <input type="text" id="editCategoryName" name="name" required>
                </div>
                <input type="hidden" id="editCategoryId" name="category_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update Category</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editCategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Subcategory Modal -->
<div class="modal" id="editSubcategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Subcategory</h2>
            <button class="close-btn" onclick="closeModal('editSubcategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editSubcategoryForm">
                <div class="form-group">
                    <label for="editSubcategoryName">Subcategory Name</label>
                    <input type="text" id="editSubcategoryName" name="name" required>
                </div>
                <input type="hidden" id="editSubcategoryId" name="subcategory_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update Subcategory</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editSubcategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let categories = [];
let currentBudget = null;
let overAllocationTimeout = null;

document.addEventListener('DOMContentLoaded', function() {
    // Initialize loading states
    LoadingManager.showMultiple(['budgetSummary', 'categoriesGrid', 'available-stat', 'allocated-stat', 'spent-stat']);
    
    // Load data immediately, currency will be loaded globally
    loadBudgetData();
    loadCategories();
    
    // Also listen for currency loaded event
    window.addEventListener('currencyLoaded', function(event) {
        userCurrency = event.detail.currency;
        updateCurrencySymbols();
        loadBudgetData();
        loadCategories();
    });
    
    // Listen for budget period changes
    window.addEventListener('budgetPeriodChanged', function(event) {
        loadBudgetData();
        loadCategories();
    });
    
    setupFormListeners();
    setupScrollListener();
    
    // Test notification (remove this after testing)
    // setTimeout(() => showNotification('Budget breakdown loaded successfully!', 'success'), 1000);
});

function updateCurrencySymbols() {
    // Update currency symbols in input fields
    const currencySymbol = getCurrencySymbol(userCurrency);
    document.querySelectorAll('[data-currency-symbol]').forEach(element => {
        element.textContent = currencySymbol;
    });
}

function loadBudgetData() {
    fetch('/api/budget/budget', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => response.json())
    .then(data => {
        currentBudget = data;
        updateBudgetSummary();
        
        // Hide budget summary loading state
        LoadingManager.hide('budgetSummary');
    })
    .catch(error => {
        console.error('Error loading budget:', error);
        // Hide loading state even on error
        LoadingManager.hide('budgetSummary');
    });
}

function updateBudgetSummary() {
    if (!currentBudget) return;
    
    // Calculate total allocated and spent from categories if available
    let totalAllocated = 0;
    let totalSpent = 0;
    
    if (categories && categories.length > 0) {
        categories.forEach(category => {
            category.subcategories.forEach(subcategory => {
                totalAllocated += subcategory.allocated || 0;
                totalSpent += subcategory.spent || 0;
            });
        });
    }
    
    // Calculate available to allocate from budget data
    const totalIncome = currentBudget.total_income || 0;
    const balanceBroughtForward = currentBudget.balance_brought_forward || 0;
    const totalAvailable = totalIncome + balanceBroughtForward;
    const availableToAllocate = totalAvailable - totalAllocated;
    
    document.getElementById('availableToAllocate').textContent = formatCurrency(availableToAllocate, userCurrency);
    document.getElementById('totalAllocated').textContent = formatCurrency(totalAllocated, userCurrency);
    document.getElementById('totalSpent').textContent = formatCurrency(totalSpent, userCurrency);
    
    // Only hide loading states for individual stats if we have both budget and categories data
    if (currentBudget && categories && categories.length > 0) {
        LoadingManager.hideMultiple(['available-stat', 'allocated-stat', 'spent-stat']);
    }
}

function toggleBudgetSummary() {
    const summary = document.getElementById('budgetSummary');
    const stickyBadge = document.getElementById('stickyAvailableBadge');
    const availableElement = document.getElementById('availableToAllocate');
    
    summary.classList.toggle('collapsed');
    
    // Show/hide sticky badge
    if (summary.classList.contains('collapsed')) {
        stickyBadge.classList.add('show');
        updateStickyBadge();
    } else {
        stickyBadge.classList.remove('show');
    }
}

function setupScrollListener() {
    let isCollapsed = false;
    let lastScrollY = window.scrollY;
    
    window.addEventListener('scroll', () => {
        const currentScrollY = window.scrollY;
        const summary = document.getElementById('budgetSummary');
        const stickyBadge = document.getElementById('stickyAvailableBadge');
        
        if (currentScrollY > 100 && !isCollapsed) {
            summary.classList.add('collapsed');
            stickyBadge.classList.add('show');
            updateStickyBadge();
            isCollapsed = true;
        } else if (currentScrollY <= 100 && isCollapsed) {
            summary.classList.remove('collapsed');
            stickyBadge.classList.remove('show');
            isCollapsed = false;
        }
        
        lastScrollY = currentScrollY;
    });
}

function updateStickyBadge() {
    const availableElement = document.getElementById('availableToAllocate');
    const stickyAmount = document.getElementById('stickyAvailableAmount');
    const stickyBadge = document.getElementById('stickyAvailableBadge');
    
    if (availableElement && stickyAmount && stickyBadge) {
        stickyAmount.textContent = availableElement.textContent;
        
        // Add visual indicator for negative amounts
        const amount = parseFloat(availableElement.textContent.replace(/[^0-9.-]/g, ''));
        if (amount < 0) {
            stickyBadge.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
            stickyBadge.style.borderColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            stickyBadge.style.background = 'linear-gradient(135deg, #8B4513 0%, #D2691E 100%)';
            stickyBadge.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
    }
}

function checkOverAllocation() {
    if (!currentBudget) return;
    
    // Clear previous timeout
    if (overAllocationTimeout) {
        clearTimeout(overAllocationTimeout);
    }
    
    // Debounce the check to avoid too many notifications while typing
    overAllocationTimeout = setTimeout(() => {
        // Calculate total income from budget data
        const totalIncome = currentBudget.total_income || 0;
        const balanceForward = currentBudget.balance_brought_forward || 0;
        const totalAvailable = totalIncome + balanceForward;
        
        // Calculate total allocated
        const totalAllocated = categories.reduce((sum, category) => {
            return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.allocated || 0), 0);
        }, 0);
        
        const available = totalAvailable - totalAllocated;
        
        // Show error if over-allocated
        if (available < 0) {
            const overAmount = Math.abs(available);
            showNotification(`Warning: You have over-allocated by ${formatCurrency(overAmount, userCurrency)}. Total allocations exceed available funds.`, 'error');
        }
    }, 500); // 500ms delay
}

function loadCategories() {
    fetch('/api/categories/categories', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => response.json())
    .then(data => {
        categories = data;
        
        // Ensure all subcategories have proper allocated values
        categories.forEach(category => {
            category.subcategories.forEach(sub => {
                if (sub.allocated === undefined || sub.allocated === null) {
                    sub.allocated = 0;
                }
                if (sub.spent === undefined || sub.spent === null) {
                    sub.spent = 0;
                }
                if (sub.balance === undefined || sub.balance === null) {
                    sub.balance = sub.allocated - sub.spent;
                }
            });
        });
        
        renderCategories();
        updateBudgetSummary(); // Update summary after loading categories
        
        // Hide categories grid loading state
        LoadingManager.hide('categoriesGrid');
    })
    .catch(error => {
        console.error('Error loading categories:', error);
        // Hide loading state even on error
        LoadingManager.hide('categoriesGrid');
    });
}

function renderCategories() {
    const grid = document.getElementById('categoriesGrid');
    
    grid.innerHTML = categories.map(category => {
        const categoryAllocated = category.subcategories.reduce((sum, sub) => sum + sub.allocated, 0);
        const categorySpent = category.subcategories.reduce((sum, sub) => sum + sub.spent, 0);
        const categoryBalance = categoryAllocated - categorySpent;
        
        return `
            <div class="category-card">
                <div class="category-header">
                    <h3>${category.name}</h3>
                    <div class="category-actions">
                        <button class="btn btn-sm btn-secondary" onclick="showEditCategoryModal(${category.id}, '${category.name}')" title="Edit Category">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteCategory(${category.id})" title="Delete Category">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="category-totals">
                    <div class="total-row">
                        <span class="total-label">Allocated Fund:</span>
                        <span class="total-value allocated">${formatCurrency(categoryAllocated)}</span>
                    </div>
                    <div class="total-row">
                        <span class="total-label">Expenditure:</span>
                        <span class="total-value spent">${formatCurrency(categorySpent)}</span>
                    </div>
                    <div class="total-row">
                        <span class="total-label">Difference:</span>
                        <span class="total-value balance ${categoryBalance < 0 ? 'negative' : 'positive'}">${formatCurrency(categoryBalance)}</span>
                    </div>
                </div>
                
                <div class="subcategories">
                    ${category.subcategories.map(sub => `
                        <div class="subcategory-row">
                            <div class="subcategory-info">
                                <span class="subcategory-name">
                                    ${sub.name}
                                    ${sub.is_recurring_allocation ? '<i class="fas fa-sync-alt" style="color: #28a745; margin-left: 8px;" title="Recurring Allocation"></i>' : ''}
                                </span>
                                <div class="subcategory-actions">
                                    <button class="btn btn-xs btn-secondary" onclick="showEditSubcategoryModal(${sub.id}, '${sub.name}')" title="Edit">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="btn btn-xs btn-danger" onclick="deleteSubcategory(${sub.id})" title="Delete">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="subcategory-amounts">
                                <div class="amount-group">
                                    <span class="amount-label">Allocated:</span>
                                    <div class="input-group">
                                        <input type="number" 
                                               class="allocation-amount" 
                                               data-subcategory-id="${sub.id}"
                                               value="${sub.allocated || 0}"
                                               step="0.01" 
                                               min="0">
                                    </div>
                                </div>
                                <div class="amount-group">
                                    <span class="amount-label">Spent:</span>
                                    <span class="amount-value spent">${formatCurrency(sub.spent)}</span>
                                </div>
                                <div class="amount-group">
                                    <span class="amount-label">Balance:</span>
                                    <span class="amount-value balance ${sub.balance < 0 ? 'negative' : 'positive'}">${formatCurrency(sub.balance)}</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                    
                    <div class="add-subcategory">
                        <button class="btn btn-sm btn-outline" onclick="showAddSubcategoryModal(${category.id})">
                            <i class="fas fa-plus"></i>
                            Add Subcategory
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add event listeners to allocation inputs
    document.querySelectorAll('.allocation-amount').forEach(input => {
        // Format existing values on load
        if (input.value && input.value !== '') {
            const value = parseFloat(input.value);
            if (!isNaN(value)) {
                input.value = value.toFixed(2);
            }
        }
        
        input.addEventListener('input', updateAllocation);
        input.addEventListener('change', updateAllocation);
        input.addEventListener('blur', updateAllocation);
    });
    
    // Update currency symbols after rendering
    updateCurrencySymbols();
}

function updateAllocation(e) {
    const subcategoryId = parseInt(e.target.dataset.subcategoryId);
    let amount = parseFloat(e.target.value) || 0;
    
    // Ensure amount is a valid number
    if (isNaN(amount)) {
        amount = 0;
    }
    
    // Don't format during typing, only on blur
    if (e.type === 'blur') {
        const formattedValue = amount.toFixed(2);
        e.target.value = formattedValue;
    }
    
    // Update the local data
    let updatedCategory = null;
    let updatedSubcategory = null;
    
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            if (sub.id === subcategoryId) {
                sub.allocated = amount;
                sub.balance = (sub.allocated || 0) - (sub.spent || 0);
                updatedCategory = category;
                updatedSubcategory = sub;
            }
        });
    });
    
    // Update the specific subcategory balance display in real-time
    if (updatedSubcategory) {
        const balanceElement = e.target.closest('.subcategory-row').querySelector('.amount-value.balance');
        if (balanceElement) {
            balanceElement.textContent = formatCurrency(updatedSubcategory.balance, userCurrency);
            balanceElement.className = `amount-value balance ${updatedSubcategory.balance < 0 ? 'negative' : 'positive'}`;
        }
    }
    
    // Update category totals in real-time
    if (updatedCategory) {
        updateCategoryTotals(updatedCategory);
    }
    
    updateTotals();
    
    // Check for over-allocation and show error in real-time
    checkOverAllocation();
    
    // Update sticky badge in real-time
    const summary = document.getElementById('budgetSummary');
    if (summary.classList.contains('collapsed')) {
        updateStickyBadge();
    }
    
    // Only save on blur to avoid excessive API calls
    if (e.type === 'blur') {
        saveAllocations();
    }
}

function updateCategoryTotals(category) {
    const categoryAllocated = category.subcategories.reduce((sum, sub) => sum + (sub.allocated || 0), 0);
    const categorySpent = category.subcategories.reduce((sum, sub) => sum + (sub.spent || 0), 0);
    const categoryBalance = categoryAllocated - categorySpent;
    
    // Find the category card in the DOM
    const categoryCards = document.querySelectorAll('.category-card');
    let targetCard = null;
    
    // Find the card by looking for the category name in the header
    categoryCards.forEach(card => {
        const header = card.querySelector('.category-header h3');
        if (header && header.textContent.trim() === category.name) {
            targetCard = card;
        }
    });
    
    if (targetCard) {
        // Update allocated fund
        const allocatedElement = targetCard.querySelector('.total-value.allocated');
        if (allocatedElement) {
            allocatedElement.textContent = formatCurrency(categoryAllocated, userCurrency);
        }
        
        // Update difference (balance)
        const balanceElement = targetCard.querySelector('.total-value.balance');
        if (balanceElement) {
            balanceElement.textContent = formatCurrency(categoryBalance, userCurrency);
            balanceElement.className = `total-value balance ${categoryBalance < 0 ? 'negative' : 'positive'}`;
        }
    }
}

function updateTotals() {
    const totalAllocated = categories.reduce((sum, category) => {
        return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.allocated || 0), 0);
    }, 0);
    
    const totalSpent = categories.reduce((sum, category) => {
        return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.spent || 0), 0);
    }, 0);
    
    document.getElementById('totalAllocated').textContent = formatCurrency(totalAllocated, userCurrency);
    document.getElementById('totalSpent').textContent = formatCurrency(totalSpent, userCurrency);
    
    if (currentBudget) {
        // Calculate total income from budget data
        const totalIncome = currentBudget.total_income || 0;
        const balanceForward = currentBudget.balance_brought_forward || 0;
        const totalAvailable = totalIncome + balanceForward;
        
        const available = totalAvailable - totalAllocated;
        const availableElement = document.getElementById('availableToAllocate');
        
        // Ensure we're working with numbers
        const availableAmount = parseFloat(available) || 0;
        availableElement.textContent = formatCurrency(availableAmount, userCurrency);
        availableElement.className = `stat-value ${availableAmount < 0 ? 'negative' : 'positive'}`;
        
        // Update sticky badge if visible
        const summary = document.getElementById('budgetSummary');
        if (summary.classList.contains('collapsed')) {
            updateStickyBadge();
        }
    }
}

function saveAllocations() {
    const allocations = [];
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            // Ensure allocated is a valid number and greater than 0
            const allocatedAmount = parseFloat(sub.allocated) || 0;
            if (allocatedAmount > 0) {
                allocations.push({
                    subcategory_id: sub.id,
                    allocated_amount: allocatedAmount
                });
            }
        });
    });
    
    
    fetch('/api/budget/allocations', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({ allocations })
    })
    .then(response => response.json())
    .then(data => {
        if (data.message && data.message.includes('cannot exceed')) {
            showNotification(data.message, 'error');
        } else {
            showNotification('Allocations saved successfully!', 'success');
            loadBudgetData(); // Refresh budget data
            // Dispatch event to refresh dashboard
            window.dispatchEvent(new CustomEvent('budgetDataChanged', {
                detail: { type: 'allocations_updated' }
            }));
        }
    })
    .catch(error => {
        console.error('Error saving allocations:', error);
        showNotification('Error saving allocations. Please try again.', 'error');
    });
}

// Modal functions
function showAddCategoryModal() {
    document.getElementById('addCategoryModal').style.display = 'block';
}

function showAddSubcategoryModal(categoryId) {
    document.getElementById('parentCategoryId').value = categoryId;
    document.getElementById('addSubcategoryModal').style.display = 'block';
}

function showEditCategoryModal(categoryId, categoryName) {
    document.getElementById('editCategoryId').value = categoryId;
    document.getElementById('editCategoryName').value = categoryName;
    document.getElementById('editCategoryModal').style.display = 'block';
}

function showEditSubcategoryModal(subcategoryId, subcategoryName) {
    document.getElementById('editSubcategoryId').value = subcategoryId;
    document.getElementById('editSubcategoryName').value = subcategoryName;
    document.getElementById('editSubcategoryModal').style.display = 'block';
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

// CRUD operations
function deleteCategory(categoryId) {
    if (confirm('Are you sure you want to delete this category? This will also delete all subcategories and allocations.')) {
        fetch(`/api/categories/categories/${categoryId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': 'Bearer ' + getToken()
            }
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Category deleted successfully!', 'success');
            loadCategories();
        })
        .catch(error => {
            console.error('Error deleting category:', error);
            showNotification('Error deleting category. Please try again.', 'error');
        });
    }
}

function deleteSubcategory(subcategoryId) {
    if (confirm('Are you sure you want to delete this subcategory?')) {
        fetch(`/api/categories/subcategories/${subcategoryId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': 'Bearer ' + getToken()
            }
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Subcategory deleted successfully!', 'success');
            loadCategories();
        })
        .catch(error => {
            console.error('Error deleting subcategory:', error);
            showNotification('Error deleting subcategory. Please try again.', 'error');
        });
    }
}

function setupFormListeners() {
    document.getElementById('addCategoryForm').addEventListener('submit', handleAddCategory);
    document.getElementById('addSubcategoryForm').addEventListener('submit', handleAddSubcategory);
    document.getElementById('editCategoryForm').addEventListener('submit', handleEditCategory);
    document.getElementById('editSubcategoryForm').addEventListener('submit', handleEditSubcategory);
}

function handleAddCategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    
    fetch('/api/categories/categories', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Category added successfully!', 'success');
        closeModal('addCategoryModal');
        e.target.reset();
        loadCategories();
    })
    .catch(error => {
        console.error('Error adding category:', error);
        showNotification('Error adding category. Please try again.', 'error');
    });
}

function handleAddSubcategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    
    fetch('/api/categories/subcategories', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name'),
            category_id: parseInt(formData.get('category_id'))
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Subcategory added successfully!', 'success');
        closeModal('addSubcategoryModal');
        e.target.reset();
        loadCategories();
    })
    .catch(error => {
        console.error('Error adding subcategory:', error);
        showNotification('Error adding subcategory. Please try again.', 'error');
    });
}

function handleEditCategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    const categoryId = formData.get('category_id');
    
    fetch(`/api/categories/categories/${categoryId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Category updated successfully!', 'success');
        closeModal('editCategoryModal');
        loadCategories();
    })
    .catch(error => {
        console.error('Error updating category:', error);
        showNotification('Error updating category. Please try again.', 'error');
    });
}

function handleEditSubcategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    const subcategoryId = formData.get('subcategory_id');
    
    fetch(`/api/categories/subcategories/${subcategoryId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Subcategory updated successfully!', 'success');
        closeModal('editSubcategoryModal');
        loadCategories();
    })
    .catch(error => {
        console.error('Error updating subcategory:', error);
        showNotification('Error updating subcategory. Please try again.', 'error');
    });
}

function showNotification(message, type = 'info') {
    // Remove any existing notifications
    const existingNotification = document.querySelector('.notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Set all styles inline to ensure visibility
    notification.style.cssText = `
        position: fixed !important;
        top: 80px !important;
        right: 20px !important;
        z-index: 9999 !important;
        max-width: 300px !important;
        word-wrap: break-word !important;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
        padding: 1rem 1.5rem !important;
        border-radius: 8px !important;
        color: white !important;
        font-weight: 500 !important;
        font-size: 14px !important;
        line-height: 1.4 !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        transform: none !important;
        ${type === 'error' ? 
            'background: #dc3545 !important; border-left: 4px solid #c82333 !important;' : 
            type === 'success' ? 
            'background: #28a745 !important; border-left: 4px solid #1e7e34 !important;' : 
            'background: #007bff !important; border-left: 4px solid #0056b3 !important;'
        }
    `;
    
    // Add to page
    document.body.appendChild(notification);
    
    // Force a reflow to ensure visibility
    notification.offsetHeight;
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

function formatCurrency(amount, currency = userCurrency || 'USD') {
    const symbol = getCurrencySymbol(currency);
    const formatter = new Intl.NumberFormat('en-US', {
        style: 'decimal',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    return symbol + formatter.format(amount || 0);
}

// Recurring Allocations Management Functions
function showRecurringAllocationsModal() {
    document.getElementById('recurringAllocationsModal').style.display = 'block';
    loadRecurringAllocations();
    populateSubcategoryDropdown();
}

function showAddRecurringAllocationModal() {
    document.getElementById('addRecurringAllocationModal').style.display = 'block';
    populateSubcategoryDropdown();
}

function showEditRecurringAllocationModal(allocationId, allocatedAmount) {
    document.getElementById('editRecurringAllocationId').value = allocationId;
    document.getElementById('editRecurringAllocationAmount').value = allocatedAmount;
    document.getElementById('editRecurringAllocationModal').style.display = 'block';
}

function populateSubcategoryDropdown() {
    const select = document.getElementById('recurringSubcategory');
    select.innerHTML = '<option value="">Select a subcategory</option>';
    
    categories.forEach(category => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category.name;
        
        category.subcategories.forEach(subcategory => {
            const option = document.createElement('option');
            option.value = subcategory.id;
            option.textContent = subcategory.name;
            optgroup.appendChild(option);
        });
        
        select.appendChild(optgroup);
    });
}

function loadRecurringAllocations() {
    fetch('/api/recurring-allocations', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => response.json())
    .then(data => {
        renderRecurringAllocations(data);
    })
    .catch(error => console.error('Error loading recurring allocations:', error));
}

function renderRecurringAllocations(allocations) {
    const container = document.getElementById('recurringAllocationsList');
    
    if (allocations.length === 0) {
        container.innerHTML = `
            <div class="no-recurring-allocations">
                <i class="fas fa-repeat"></i>
                <p>No recurring allocations set up</p>
                <p>Click "Add Recurring Allocation" to get started</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = allocations.map(allocation => `
        <div class="recurring-allocation-item">
            <div class="allocation-info">
                <div class="allocation-category">${allocation.category_name}</div>
                <div class="allocation-subcategory">${allocation.subcategory_name}</div>
                <div class="allocation-amount">${formatCurrency(allocation.allocated_amount, userCurrency)}</div>
            </div>
            <div class="allocation-actions">
                <button class="btn btn-secondary" onclick="showEditRecurringAllocationModal(${allocation.id}, ${allocation.allocated_amount})" title="Edit">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-danger" onclick="deleteRecurringAllocation(${allocation.id})" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// Add event listeners for recurring allocation forms
document.addEventListener('DOMContentLoaded', function() {
    const addRecurringAllocationForm = document.getElementById('addRecurringAllocationForm');
    const editRecurringAllocationForm = document.getElementById('editRecurringAllocationForm');
    
    if (addRecurringAllocationForm) {
        addRecurringAllocationForm.addEventListener('submit', handleAddRecurringAllocation);
    }
    
    if (editRecurringAllocationForm) {
        editRecurringAllocationForm.addEventListener('submit', handleEditRecurringAllocation);
    }
});

function handleAddRecurringAllocation(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const data = {
        subcategory_id: parseInt(formData.get('subcategory_id')),
        allocated_amount: parseFloat(formData.get('allocated_amount'))
    };
    
    fetch('/api/recurring-allocations', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Recurring allocation added successfully!', 'success');
        closeModal('addRecurringAllocationModal');
        e.target.reset();
        loadRecurringAllocations();
    })
    .catch(error => {
        console.error('Error adding recurring allocation:', error);
        showNotification('Error adding recurring allocation. Please try again.', 'error');
    });
}

function handleEditRecurringAllocation(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const allocationId = formData.get('allocation_id');
    const data = {
        allocated_amount: parseFloat(formData.get('allocated_amount'))
    };
    
    fetch(`/api/recurring-allocations/${allocationId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Recurring allocation updated successfully!', 'success');
        closeModal('editRecurringAllocationModal');
        loadRecurringAllocations();
    })
    .catch(error => {
        console.error('Error updating recurring allocation:', error);
        showNotification('Error updating recurring allocation. Please try again.', 'error');
    });
}

function deleteRecurringAllocation(allocationId) {
    if (confirm('Are you sure you want to delete this recurring allocation? This will remove it from future budgets but not affect current allocations.')) {
        fetch(`/api/recurring-allocations/${allocationId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': 'Bearer ' + getToken()
            }
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Recurring allocation deleted successfully!', 'success');
            loadRecurringAllocations();
            // Reload categories to update the recurring icon display
            loadCategories();
        })
        .catch(error => {
            console.error('Error deleting recurring allocation:', error);
            showNotification('Error deleting recurring allocation. Please try again.', 'error');
        });
    }
}

// Debug and cleanup functions removed from user interface
// These are available as API endpoints for admin use if needed
</script>
{% endblock %}


