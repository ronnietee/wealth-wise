{% extends "base.html" %}

{% block title %}Breakdown - STEWARD{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1>Budget Breakdown</h1>
        <p class="page-subtitle">Allocate and manage your budget across categories</p>
    </div>

    <div class="breakdown-container">
        <!-- Sticky Available Badge -->
        <div class="sticky-available-badge" id="stickyAvailableBadge">
            <span class="label">Available to allocate:</span>
            <span class="amount" id="stickyAvailableAmount">$0.00</span>
        </div>
        
        <!-- Budget Summary -->
        <div class="card budget-summary" id="budgetSummary">
            <div class="budget-summary-header" onclick="toggleBudgetSummary()">
                <h2>Budget Summary</h2>
                <i class="fas fa-chevron-up collapse-icon"></i>
            </div>
            <div class="card-body">
                <div class="budget-stats">
                    <div class="budget-stat" id="available-stat">
                        <span class="stat-label">Available to Allocate:</span>
                        <span class="stat-value" id="availableToAllocate">$0.00</span>
                    </div>
                    <div class="budget-stat" id="allocated-stat">
                        <span class="stat-label">Total Allocated:</span>
                        <span class="stat-value" id="totalAllocated">$0.00</span>
                    </div>
                    <div class="budget-stat" id="spent-stat">
                        <span class="stat-label">Total Spent:</span>
                        <span class="stat-value" id="totalSpent">$0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Categories Grid -->
        <div class="categories-grid" id="categoriesGrid">
            <!-- Categories will be loaded here -->
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons-section">
            <button class="btn btn-secondary btn-large" onclick="showRecurringAllocationsModal()">
                <i class="fas fa-repeat"></i>
                Manage Recurring Allocations
            </button>
            <button class="btn btn-primary btn-large" onclick="showAddCategoryModal()">
                <i class="fas fa-plus"></i>
                Add New Category
            </button>
        </div>
    </div>
    
    <!-- Floating Record Transaction Button -->
    <button class="floating-record-btn" onclick="openAddExpenseModal()" title="Record New Transaction">
        <i class="fas fa-plus"></i>
        <span class="floating-btn-text">Record Transaction</span>
    </button>
</div>

<!-- Recurring Allocations Modal -->
<div class="modal" id="recurringAllocationsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Manage Recurring Allocations</h2>
            <button class="close-btn" onclick="closeModal('recurringAllocationsModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="recurring-section">
                <div class="section-header">
                    <h3>Recurring Budget Allocations</h3>
                    <button class="btn btn-primary" onclick="showAddRecurringAllocationModal()">
                        <i class="fas fa-plus"></i>
                        Add Recurring Allocation
                    </button>
                </div>
                <div id="recurringAllocationsList" class="recurring-list">
                    <!-- Recurring allocations will be loaded here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Recurring Allocation Modal -->
<div class="modal" id="addRecurringAllocationModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add Recurring Allocation</h2>
            <button class="close-btn" onclick="closeModal('addRecurringAllocationModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addRecurringAllocationForm">
                <div class="form-group">
                    <label for="recurringSubcategory">Subcategory</label>
                    <select id="recurringSubcategory" name="subcategory_id" required>
                        <option value="">Select a subcategory</option>
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="recurringAllocationAmount">Allocation Amount</label>
                    <div class="input-group">
                        <span class="input-prefix" data-currency-symbol>$</span>
                        <input type="number" id="recurringAllocationAmount" name="allocated_amount" step="0.01" min="0.01" required>
                    </div>
                </div>
                <div class="form-group">
                    <label for="recurringAllocationPeriodType">Period Type</label>
                    <select id="recurringAllocationPeriodType" name="period_type" required>
                        <option value="monthly">Monthly</option>
                        <option value="quarterly">Quarterly</option>
                        <option value="yearly">Yearly</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Recurring Allocation</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addRecurringAllocationModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Recurring Allocation Modal -->
<div class="modal" id="editRecurringAllocationModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Recurring Allocation</h2>
            <button class="close-btn" onclick="closeModal('editRecurringAllocationModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editRecurringAllocationForm">
                <div class="form-group">
                    <label for="editRecurringAllocationAmount">Allocation Amount</label>
                    <div class="input-group">
                        <span class="input-prefix" data-currency-symbol>$</span>
                        <input type="number" id="editRecurringAllocationAmount" name="allocated_amount" step="0.01" min="0.01" required>
                    </div>
                </div>
                <input type="hidden" id="editRecurringAllocationId" name="allocation_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editRecurringAllocationModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Add Category Modal -->
<div class="modal" id="addCategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add New Category</h2>
            <button class="close-btn" onclick="closeModal('addCategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addCategoryForm">
                <div class="form-group">
                    <label for="categoryName">Category Name</label>
                    <input type="text" id="categoryName" name="name" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Category</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addCategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Add Subcategory Modal -->
<div class="modal" id="addSubcategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add New Subcategory</h2>
            <button class="close-btn" onclick="closeModal('addSubcategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="addSubcategoryForm">
                <div class="form-group">
                    <label for="subcategoryName">Subcategory Name</label>
                    <input type="text" id="subcategoryName" name="name" required>
                </div>
                <input type="hidden" id="parentCategoryId" name="category_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Subcategory</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('addSubcategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Category Modal -->
<div class="modal" id="editCategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Category</h2>
            <button class="close-btn" onclick="closeModal('editCategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editCategoryForm">
                <div class="form-group">
                    <label for="editCategoryName">Category Name</label>
                    <input type="text" id="editCategoryName" name="name" required>
                </div>
                <input type="hidden" id="editCategoryId" name="category_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update Category</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editCategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Edit Subcategory Modal -->
<div class="modal" id="editSubcategoryModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Subcategory</h2>
            <button class="close-btn" onclick="closeModal('editSubcategoryModal')">&times;</button>
        </div>
        <div class="modal-body">
            <form id="editSubcategoryForm">
                <div class="form-group">
                    <label for="editSubcategoryName">Subcategory Name</label>
                    <input type="text" id="editSubcategoryName" name="name" required>
                </div>
                <input type="hidden" id="editSubcategoryId" name="subcategory_id">
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Update Subcategory</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editSubcategoryModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let categories = [];
let currentBudget = null;
let overAllocationTimeout = null;
let saveAllocationsTimeout = null;

document.addEventListener('DOMContentLoaded', function() {
    // Initialize loading states
    LoadingManager.showMultiple(['budgetSummary', 'categoriesGrid', 'available-stat', 'allocated-stat', 'spent-stat']);
    
    // Load data immediately, currency will be loaded globally
    loadBudgetData();
    loadCategories();
    
    // Safety timeout - hide all loading states after 10 seconds even if requests fail
    setTimeout(function() {
        LoadingManager.hideMultiple(['budgetSummary', 'categoriesGrid', 'available-stat', 'allocated-stat', 'spent-stat']);
    }, 10000);
    
    // Also listen for currency loaded event
    window.addEventListener('currencyLoaded', function(event) {
        userCurrency = event.detail.currency;
        updateCurrencySymbols();
        loadBudgetData();
        loadCategories();
    });
    
    // Listen for budget period changes
    window.addEventListener('budgetPeriodChanged', function(event) {
        loadBudgetData();
        loadCategories();
    });
    
    setupFormListeners();
    setupScrollListener();
    
    // Test notification (remove this after testing)
    // setTimeout(() => showNotification('Budget breakdown loaded successfully!', 'success'), 1000);
});

function updateCurrencySymbols() {
    // Update currency symbols in input fields
    const currencySymbol = getCurrencySymbol(userCurrency);
    document.querySelectorAll('[data-currency-symbol]').forEach(element => {
        element.textContent = currencySymbol;
    });
}

function loadBudgetData() {
    fetch('/api/budget/budget', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            // If 404, no active budget - that's okay, just set to null
            if (response.status === 404) {
                currentBudget = null;
                updateBudgetSummary();
                LoadingManager.hide('budgetSummary');
                return null; // Return null to prevent further processing
            }
            // For other errors, try to parse JSON error, otherwise throw
            return response.text().then(text => {
                try {
                    const err = JSON.parse(text);
                    return Promise.reject(err);
                } catch {
                    return Promise.reject(new Error(`HTTP ${response.status}: ${response.statusText}`));
                }
            });
        }
        return response.json();
    })
    .then(data => {
        if (data) {
            currentBudget = data;
        } else {
            currentBudget = null;
        }
        updateBudgetSummary();
        
        // Hide budget summary loading state
        LoadingManager.hide('budgetSummary');
    })
    .catch(error => {
        console.error('Error loading budget:', error);
        // Hide loading state even on error
        LoadingManager.hide('budgetSummary');
        // Set currentBudget to null so page can still render
        currentBudget = null;
        updateBudgetSummary();
    });
}

function updateBudgetSummary() {
    // Calculate total allocated and spent from categories if available
    let totalAllocated = 0;
    let totalSpent = 0;
    
    if (categories && Array.isArray(categories) && categories.length > 0) {
        categories.forEach(category => {
            if (category.subcategories && Array.isArray(category.subcategories)) {
                category.subcategories.forEach(subcategory => {
                    totalAllocated += subcategory.allocated || 0;
                    totalSpent += Math.abs(subcategory.spent || 0);
                });
            }
        });
    }
    
    // Calculate available to allocate from budget data
    let totalIncome = 0;
    let balanceBroughtForward = 0;
    
    if (currentBudget) {
        totalIncome = currentBudget.total_income || 0;
        balanceBroughtForward = currentBudget.balance_brought_forward || 0;
    }
    
    const totalAvailable = totalIncome + balanceBroughtForward;
    const availableToAllocate = totalAvailable - totalAllocated;
    
    // Update UI elements safely
    const availableEl = document.getElementById('availableToAllocate');
    const allocatedEl = document.getElementById('totalAllocated');
    const spentEl = document.getElementById('totalSpent');
    
    if (availableEl) {
        availableEl.textContent = formatCurrency(availableToAllocate, userCurrency);
    }
    if (allocatedEl) {
        allocatedEl.textContent = formatCurrency(totalAllocated, userCurrency);
    }
    if (spentEl) {
        spentEl.textContent = formatCurrency(totalSpent, userCurrency);
    }
    
    // Update sticky badge
    const stickyBadge = document.getElementById('stickyAvailableAmount');
    if (stickyBadge) {
        stickyBadge.textContent = formatCurrency(availableToAllocate, userCurrency);
    }
    
    // Always hide loading states - even if no budget, show zeros
    LoadingManager.hideMultiple(['available-stat', 'allocated-stat', 'spent-stat']);
}

function toggleBudgetSummary() {
    const summary = document.getElementById('budgetSummary');
    const stickyBadge = document.getElementById('stickyAvailableBadge');
    const availableElement = document.getElementById('availableToAllocate');
    
    summary.classList.toggle('collapsed');
    
    // Show/hide sticky badge
    if (summary.classList.contains('collapsed')) {
        stickyBadge.classList.add('show');
        updateStickyBadge();
    } else {
        stickyBadge.classList.remove('show');
    }
}

function setupScrollListener() {
    let isCollapsed = false;
    let lastScrollY = window.scrollY;
    
    window.addEventListener('scroll', () => {
        const currentScrollY = window.scrollY;
        const summary = document.getElementById('budgetSummary');
        const stickyBadge = document.getElementById('stickyAvailableBadge');
        
        if (currentScrollY > 100 && !isCollapsed) {
            summary.classList.add('collapsed');
            stickyBadge.classList.add('show');
            updateStickyBadge();
            isCollapsed = true;
        } else if (currentScrollY <= 100 && isCollapsed) {
            summary.classList.remove('collapsed');
            stickyBadge.classList.remove('show');
            isCollapsed = false;
        }
        
        lastScrollY = currentScrollY;
    });
}

function updateStickyBadge() {
    const availableElement = document.getElementById('availableToAllocate');
    const stickyAmount = document.getElementById('stickyAvailableAmount');
    const stickyBadge = document.getElementById('stickyAvailableBadge');
    
    if (availableElement && stickyAmount && stickyBadge) {
        stickyAmount.textContent = availableElement.textContent;
        
        // Add visual indicator for negative amounts
        const amount = parseFloat(availableElement.textContent.replace(/[^0-9.-]/g, ''));
        if (amount < 0) {
            stickyBadge.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
            stickyBadge.style.borderColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            stickyBadge.style.background = 'linear-gradient(135deg, #8B4513 0%, #D2691E 100%)';
            stickyBadge.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
    }
}

function checkOverAllocation() {
    if (!currentBudget) return;
    
    // Clear previous timeout
    if (overAllocationTimeout) {
        clearTimeout(overAllocationTimeout);
    }
    
    // Debounce the check to avoid too many notifications while typing
    overAllocationTimeout = setTimeout(() => {
        // Calculate total income from budget data
        const totalIncome = currentBudget.total_income || 0;
        const balanceForward = currentBudget.balance_brought_forward || 0;
        const totalAvailable = totalIncome + balanceForward;
        
        // Calculate total allocated
        const totalAllocated = categories.reduce((sum, category) => {
            return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.allocated || 0), 0);
        }, 0);
        
        const available = totalAvailable - totalAllocated;
        
        // Show error if over-allocated
        if (available < 0) {
            const overAmount = Math.abs(available);
            showNotification(`Warning: You have over-allocated by ${formatCurrency(overAmount, userCurrency)}. Total allocations exceed available funds.`, 'error');
        }
    }, 500); // 500ms delay
}

function loadCategories() {
    fetch('/api/categories/categories', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(data => {
        if (data && Array.isArray(data)) {
            categories = data;
            
            // Ensure all subcategories have proper allocated values
            categories.forEach(category => {
                if (category.subcategories && Array.isArray(category.subcategories)) {
                    category.subcategories.forEach(sub => {
                        if (sub.allocated === undefined || sub.allocated === null) {
                            sub.allocated = 0;
                        }
                        if (sub.spent === undefined || sub.spent === null) {
                            sub.spent = 0;
                        }
                        if (sub.balance === undefined || sub.balance === null) {
                            sub.balance = sub.allocated - sub.spent;
                        }
                    });
                }
            });
            
            renderCategories();
            updateBudgetSummary(); // Update summary after loading categories
        } else {
            categories = [];
            renderCategories();
        }
        
        // Hide categories grid loading state
        LoadingManager.hide('categoriesGrid');
    })
    .catch(error => {
        console.error('Error loading categories:', error);
        // Hide loading state even on error
        LoadingManager.hide('categoriesGrid');
        // Set empty categories so page can still render
        categories = [];
        renderCategories();
    });
}

function shouldShowRecurringSymbol(subcategory) {
    // Only show recurring symbol if:
    // 1. It's a recurring allocation
    // 2. The recurring allocation's period_type matches the current budget's period_type
    if (!subcategory.is_recurring_allocation) {
        return false;
    }
    
    // If we have a current budget with period info, check if period types match
    if (currentBudget && currentBudget.period && currentBudget.period.period_type) {
        const budgetPeriodType = (currentBudget.period.period_type || '').toLowerCase().trim();
        const recurringPeriodType = (subcategory.recurring_period_type || 'monthly').toLowerCase().trim();
        
        // Default to 'monthly' if recurring_period_type is null/undefined (for backward compatibility)
        // Only show symbol if period types match
        return recurringPeriodType === budgetPeriodType;
    }
    
    // If no budget info, show symbol (backward compatibility)
    return true;
}

function renderCategories() {
    const grid = document.getElementById('categoriesGrid');
    if (!grid) return;
    
    // Preserve current allocation values from DOM before re-rendering
    const currentAllocations = new Map();
    document.querySelectorAll('.allocation-amount').forEach(input => {
        const subcategoryId = parseInt(input.dataset.subcategoryId);
        const value = parseFloat(input.value) || 0;
        if (subcategoryId && !isNaN(value)) {
            currentAllocations.set(subcategoryId, value);
        }
    });
    
    if (!categories || !Array.isArray(categories) || categories.length === 0) {
        grid.innerHTML = '<div class="empty-state"><p>No categories found. Add a category to get started.</p></div>';
        return;
    }
    
    // Restore allocation values from DOM if they exist
    // Also merge budget allocation data (including recurring info) with subcategories
    const budgetAllocationsMap = new Map();
    if (currentBudget && currentBudget.allocations && Array.isArray(currentBudget.allocations)) {
        currentBudget.allocations.forEach(alloc => {
            if (alloc.subcategory && alloc.subcategory.id) {
                budgetAllocationsMap.set(alloc.subcategory.id, {
                    allocated_amount: alloc.allocated_amount,
                    is_recurring_allocation: alloc.is_recurring_allocation || false,
                    recurring_period_type: alloc.recurring_period_type || null
                });
            }
        });
    }
    
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            if (currentAllocations.has(sub.id)) {
                sub.allocated = currentAllocations.get(sub.id);
            }
            // Merge budget allocation data
            if (budgetAllocationsMap.has(sub.id)) {
                const allocData = budgetAllocationsMap.get(sub.id);
                sub.is_recurring_allocation = allocData.is_recurring_allocation;
                // Default to 'monthly' if recurring_period_type is null/undefined (for backward compatibility)
                sub.recurring_period_type = allocData.recurring_period_type || 'monthly';
            } else {
                // Ensure these properties exist even if not in budget
                sub.is_recurring_allocation = false;
                sub.recurring_period_type = null;
            }
        });
    });
    
    grid.innerHTML = categories.map(category => {
        // Ensure subcategories exists and is an array
        const subcategories = (category.subcategories && Array.isArray(category.subcategories)) ? category.subcategories : [];
        const categoryAllocated = subcategories.reduce((sum, sub) => sum + (sub.allocated || 0), 0);
        const categorySpent = subcategories.reduce((sum, sub) => sum + Math.abs(sub.spent || 0), 0);
        const categoryBalance = categoryAllocated - categorySpent;
        
        return `
            <div class="category-card">
                <div class="category-header">
                    <h3>${category.name}</h3>
                    <div class="category-actions">
                        <button class="btn btn-sm btn-secondary" onclick="showEditCategoryModal(${category.id}, '${category.name}')" title="Edit Category">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteCategory(${category.id})" title="Delete Category">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="category-totals">
                    <div class="total-row">
                        <span class="total-label">Allocated Fund:</span>
                        <span class="total-value allocated">${formatCurrency(categoryAllocated)}</span>
                    </div>
                    <div class="total-row">
                        <span class="total-label">Expenditure:</span>
                        <span class="total-value spent">${formatCurrency(categorySpent)}</span>
                    </div>
                    <div class="total-row">
                        <span class="total-label">Difference:</span>
                        <span class="total-value balance ${categoryBalance < 0 ? 'negative' : 'positive'}">${formatCurrency(categoryBalance)}</span>
                    </div>
                </div>
                
                <div class="subcategories">
                    ${subcategories.map(sub => `
                        <div class="subcategory-row">
                            <div class="subcategory-info">
                                <span class="subcategory-name">
                                    ${sub.name}
                                    ${shouldShowRecurringSymbol(sub) ? '<i class="fas fa-sync-alt" style="color: #28a745; margin-left: 8px;" title="Recurring Allocation"></i>' : ''}
                                </span>
                                <div class="subcategory-actions">
                                    <button class="btn btn-xs btn-secondary" onclick="showEditSubcategoryModal(${sub.id}, '${sub.name}')" title="Edit">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="btn btn-xs btn-danger" onclick="deleteSubcategory(${sub.id})" title="Delete">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="subcategory-amounts">
                                <div class="amount-group">
                                    <span class="amount-label">Allocated:</span>
                                    <div class="input-group">
                                        <input type="number" 
                                               class="allocation-amount" 
                                               data-subcategory-id="${sub.id}"
                                               value="${sub.allocated || 0}"
                                               step="0.01" 
                                               min="0">
                                    </div>
                                </div>
                                <div class="amount-group">
                                    <span class="amount-label">Spent:</span>
                                    <span class="amount-value spent">${formatCurrency(sub.spent)}</span>
                                </div>
                                <div class="amount-group">
                                    <span class="amount-label">Balance:</span>
                                    <span class="amount-value balance ${sub.balance < 0 ? 'negative' : 'positive'}">${formatCurrency(sub.balance)}</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                    
                    <div class="add-subcategory">
                        <button class="btn btn-sm btn-outline" onclick="showAddSubcategoryModal(${category.id})">
                            <i class="fas fa-plus"></i>
                            Add Subcategory
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add event listeners to allocation inputs
    document.querySelectorAll('.allocation-amount').forEach(input => {
        // Format existing values on load
        if (input.value && input.value !== '') {
            const value = parseFloat(input.value);
            if (!isNaN(value)) {
                input.value = value.toFixed(2);
            }
        }
        
        input.addEventListener('input', updateAllocation);
        input.addEventListener('change', updateAllocation);
        input.addEventListener('blur', updateAllocation);
    });
    
    // Update currency symbols after rendering
    updateCurrencySymbols();
}

function updateAllocation(e) {
    const subcategoryId = parseInt(e.target.dataset.subcategoryId);
    let amount = parseFloat(e.target.value) || 0;
    
    // Ensure amount is a valid number
    if (isNaN(amount)) {
        amount = 0;
    }
    
    // Don't format during typing, only on blur
    if (e.type === 'blur') {
        const formattedValue = amount.toFixed(2);
        e.target.value = formattedValue;
    }
    
    // Update the local data
    let updatedCategory = null;
    let updatedSubcategory = null;
    
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            if (sub.id === subcategoryId) {
                sub.allocated = amount;
                sub.balance = (sub.allocated || 0) - (sub.spent || 0);
                updatedCategory = category;
                updatedSubcategory = sub;
            }
        });
    });
    
    // Update the specific subcategory balance display in real-time
    if (updatedSubcategory) {
        const balanceElement = e.target.closest('.subcategory-row').querySelector('.amount-value.balance');
        if (balanceElement) {
            balanceElement.textContent = formatCurrency(updatedSubcategory.balance, userCurrency);
            balanceElement.className = `amount-value balance ${updatedSubcategory.balance < 0 ? 'negative' : 'positive'}`;
        }
    }
    
    // Update category totals in real-time
    if (updatedCategory) {
        updateCategoryTotals(updatedCategory);
    }
    
    updateTotals();
    
    // Check for over-allocation and show error in real-time
    checkOverAllocation();
    
    // Update sticky badge in real-time
    const summary = document.getElementById('budgetSummary');
    if (summary.classList.contains('collapsed')) {
        updateStickyBadge();
    }
    
    // Save allocations with debouncing to avoid excessive API calls
    // Clear any existing timeout
    if (saveAllocationsTimeout) {
        clearTimeout(saveAllocationsTimeout);
    }
    
    // Save immediately on blur, or after 1 second of no typing
    if (e.type === 'blur') {
        saveAllocations();
    } else {
        // Debounce: save after 1 second of inactivity
        saveAllocations.silent = true; // Don't show notification on auto-save
        saveAllocationsTimeout = setTimeout(() => {
            saveAllocations().catch(() => {
                // Silently handle errors during auto-save
            }).finally(() => {
                saveAllocations.silent = false; // Reset flag
            });
        }, 1000);
    }
}

function updateCategoryTotals(category) {
    const categoryAllocated = category.subcategories.reduce((sum, sub) => sum + (sub.allocated || 0), 0);
    const categorySpent = category.subcategories.reduce((sum, sub) => sum + (sub.spent || 0), 0);
    const categoryBalance = categoryAllocated - categorySpent;
    
    // Find the category card in the DOM
    const categoryCards = document.querySelectorAll('.category-card');
    let targetCard = null;
    
    // Find the card by looking for the category name in the header
    categoryCards.forEach(card => {
        const header = card.querySelector('.category-header h3');
        if (header && header.textContent.trim() === category.name) {
            targetCard = card;
        }
    });
    
    if (targetCard) {
        // Update allocated fund
        const allocatedElement = targetCard.querySelector('.total-value.allocated');
        if (allocatedElement) {
            allocatedElement.textContent = formatCurrency(categoryAllocated, userCurrency);
        }
        
        // Update difference (balance)
        const balanceElement = targetCard.querySelector('.total-value.balance');
        if (balanceElement) {
            balanceElement.textContent = formatCurrency(categoryBalance, userCurrency);
            balanceElement.className = `total-value balance ${categoryBalance < 0 ? 'negative' : 'positive'}`;
        }
    }
}

function updateTotals() {
    const totalAllocated = categories.reduce((sum, category) => {
        return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.allocated || 0), 0);
    }, 0);
    
    const totalSpent = categories.reduce((sum, category) => {
        return sum + category.subcategories.reduce((catSum, sub) => catSum + (sub.spent || 0), 0);
    }, 0);
    
    document.getElementById('totalAllocated').textContent = formatCurrency(totalAllocated, userCurrency);
    document.getElementById('totalSpent').textContent = formatCurrency(totalSpent, userCurrency);
    
    if (currentBudget) {
        // Calculate total income from budget data
        const totalIncome = currentBudget.total_income || 0;
        const balanceForward = currentBudget.balance_brought_forward || 0;
        const totalAvailable = totalIncome + balanceForward;
        
        const available = totalAvailable - totalAllocated;
        const availableElement = document.getElementById('availableToAllocate');
        
        // Ensure we're working with numbers
        const availableAmount = parseFloat(available) || 0;
        availableElement.textContent = formatCurrency(availableAmount, userCurrency);
        availableElement.className = `stat-value ${availableAmount < 0 ? 'negative' : 'positive'}`;
        
        // Update sticky badge if visible
        const summary = document.getElementById('budgetSummary');
        if (summary.classList.contains('collapsed')) {
            updateStickyBadge();
        }
    }
}

function saveAllocations() {
    // First, collect current values from DOM inputs (they may have been changed but not saved to categories array)
    const currentAllocations = new Map();
    document.querySelectorAll('.allocation-amount').forEach(input => {
        const subcategoryId = parseInt(input.dataset.subcategoryId);
        const value = parseFloat(input.value) || 0;
        if (subcategoryId && !isNaN(value)) {
            currentAllocations.set(subcategoryId, value);
        }
    });
    
    // Update the categories array with current DOM values
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            if (currentAllocations.has(sub.id)) {
                sub.allocated = currentAllocations.get(sub.id);
            }
        });
    });
    
    const allocations = [];
    categories.forEach(category => {
        category.subcategories.forEach(sub => {
            // Ensure allocated is a valid number and greater than 0
            const allocatedAmount = parseFloat(sub.allocated) || 0;
            if (allocatedAmount > 0) {
                allocations.push({
                    subcategory_id: sub.id,
                    allocated: allocatedAmount
                });
            }
        });
    });
    
    return fetch('/api/budget/allocations', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({ allocations })
    })
    .then(response => {
        // Check if response is ok before parsing JSON
        if (!response.ok) {
            return response.text().then(text => {
                let errorData;
                try {
                    errorData = JSON.parse(text);
                } catch {
                    errorData = { message: `HTTP ${response.status}: ${response.statusText}` };
                }
                throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.message && data.message.includes('cannot exceed')) {
            showNotification(data.message, 'error');
            throw new Error(data.message);
        } else {
            // Only show success notification if not called silently
            if (!saveAllocations.silent) {
                showNotification('Allocations saved successfully!', 'success');
            }
            loadBudgetData(); // Refresh budget data
            // Dispatch event to refresh dashboard
            window.dispatchEvent(new CustomEvent('budgetDataChanged', {
                detail: { type: 'allocations_updated' }
            }));
            return data;
        }
    })
    .catch(error => {
        console.error('Error saving allocations:', error);
        console.error('Error details:', error.message, error.stack);
        if (!saveAllocations.silent) {
            const errorMessage = error.message || 'Error saving allocations. Please try again.';
            showNotification(errorMessage, 'error');
        }
        throw error;
    });
}

// Modal functions
function showAddCategoryModal() {
    document.getElementById('addCategoryModal').style.display = 'block';
}

function showAddSubcategoryModal(categoryId) {
    document.getElementById('parentCategoryId').value = categoryId;
    document.getElementById('addSubcategoryModal').style.display = 'block';
}

function showEditCategoryModal(categoryId, categoryName) {
    document.getElementById('editCategoryId').value = categoryId;
    document.getElementById('editCategoryName').value = categoryName;
    document.getElementById('editCategoryModal').style.display = 'block';
}

function showEditSubcategoryModal(subcategoryId, subcategoryName) {
    document.getElementById('editSubcategoryId').value = subcategoryId;
    document.getElementById('editSubcategoryName').value = subcategoryName;
    document.getElementById('editSubcategoryModal').style.display = 'block';
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

// CRUD operations
function deleteCategory(categoryId) {
    if (confirm('Are you sure you want to delete this category? This will also delete all subcategories and allocations.')) {
        fetch(`/api/categories/categories/${categoryId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': 'Bearer ' + getToken()
            }
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Category deleted successfully!', 'success');
            loadCategories();
        })
        .catch(error => {
            console.error('Error deleting category:', error);
            showNotification('Error deleting category. Please try again.', 'error');
        });
    }
}

function deleteSubcategory(subcategoryId) {
    if (confirm('Are you sure you want to delete this subcategory?')) {
        // Save current allocations before reloading (silently)
        saveAllocations.silent = true;
        saveAllocations().then(() => {
            saveAllocations.silent = false; // Reset flag
            fetch(`/api/categories/subcategories/${subcategoryId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': 'Bearer ' + getToken()
                }
            })
            .then(response => response.json())
            .then(data => {
                showNotification('Subcategory deleted successfully!', 'success');
                loadCategories();
            })
            .catch(error => {
                console.error('Error deleting subcategory:', error);
                showNotification('Error deleting subcategory. Please try again.', 'error');
            });
        }).catch(() => {
            saveAllocations.silent = false; // Reset flag
            // If save fails, still proceed with deletion but warn user
            fetch(`/api/categories/subcategories/${subcategoryId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': 'Bearer ' + getToken()
                }
            })
            .then(response => response.json())
            .then(data => {
                showNotification('Subcategory deleted. Note: Some allocation changes may have been lost.', 'warning');
                loadCategories();
            })
            .catch(error => {
                console.error('Error deleting subcategory:', error);
                showNotification('Error deleting subcategory. Please try again.', 'error');
            });
        });
    }
}

function setupFormListeners() {
    document.getElementById('addCategoryForm').addEventListener('submit', handleAddCategory);
    document.getElementById('addSubcategoryForm').addEventListener('submit', handleAddSubcategory);
    document.getElementById('editCategoryForm').addEventListener('submit', handleEditCategory);
    document.getElementById('editSubcategoryForm').addEventListener('submit', handleEditSubcategory);
}

function handleAddCategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    
    fetch('/api/categories/categories', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Category added successfully!', 'success');
        closeModal('addCategoryModal');
        e.target.reset();
        loadCategories();
    })
    .catch(error => {
        console.error('Error adding category:', error);
        showNotification('Error adding category. Please try again.', 'error');
    });
}

function handleAddSubcategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    
    // Save current allocations before reloading (silently)
    saveAllocations.silent = true;
    saveAllocations().then(() => {
        saveAllocations.silent = false; // Reset flag
        fetch('/api/categories/subcategories', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + getToken()
            },
            body: JSON.stringify({
                name: formData.get('name'),
                category_id: parseInt(formData.get('category_id'))
            })
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Subcategory added successfully!', 'success');
            closeModal('addSubcategoryModal');
            e.target.reset();
            loadCategories();
        })
        .catch(error => {
            console.error('Error adding subcategory:', error);
            showNotification('Error adding subcategory. Please try again.', 'error');
        });
    }).catch(() => {
        saveAllocations.silent = false; // Reset flag
        // If save fails, still proceed with adding but warn user
        fetch('/api/categories/subcategories', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + getToken()
            },
            body: JSON.stringify({
                name: formData.get('name'),
                category_id: parseInt(formData.get('category_id'))
            })
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Subcategory added. Note: Some allocation changes may have been lost.', 'warning');
            closeModal('addSubcategoryModal');
            e.target.reset();
            loadCategories();
        })
        .catch(error => {
            console.error('Error adding subcategory:', error);
            showNotification('Error adding subcategory. Please try again.', 'error');
        });
    });
}

function handleEditCategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    const categoryId = formData.get('category_id');
    
    fetch(`/api/categories/categories/${categoryId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Category updated successfully!', 'success');
        closeModal('editCategoryModal');
        loadCategories();
    })
    .catch(error => {
        console.error('Error updating category:', error);
        showNotification('Error updating category. Please try again.', 'error');
    });
}

function handleEditSubcategory(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    const subcategoryId = formData.get('subcategory_id');
    
    fetch(`/api/categories/subcategories/${subcategoryId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({
            name: formData.get('name')
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Subcategory updated successfully!', 'success');
        closeModal('editSubcategoryModal');
        loadCategories();
    })
    .catch(error => {
        console.error('Error updating subcategory:', error);
        showNotification('Error updating subcategory. Please try again.', 'error');
    });
}

function showNotification(message, type = 'info') {
    // Remove any existing notifications
    const existingNotification = document.querySelector('.notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Set all styles inline to ensure visibility
    notification.style.cssText = `
        position: fixed !important;
        top: 80px !important;
        right: 20px !important;
        z-index: 9999 !important;
        max-width: 300px !important;
        word-wrap: break-word !important;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
        padding: 1rem 1.5rem !important;
        border-radius: 8px !important;
        color: white !important;
        font-weight: 500 !important;
        font-size: 14px !important;
        line-height: 1.4 !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        transform: none !important;
        ${type === 'error' ? 
            'background: #dc3545 !important; border-left: 4px solid #c82333 !important;' : 
            type === 'success' ? 
            'background: #28a745 !important; border-left: 4px solid #1e7e34 !important;' : 
            'background: #007bff !important; border-left: 4px solid #0056b3 !important;'
        }
    `;
    
    // Add to page
    document.body.appendChild(notification);
    
    // Force a reflow to ensure visibility
    notification.offsetHeight;
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

function formatCurrency(amount, currency = userCurrency || 'USD') {
    const symbol = getCurrencySymbol(currency);
    const formatter = new Intl.NumberFormat('en-US', {
        style: 'decimal',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    return symbol + formatter.format(amount || 0);
}

// Recurring Allocations Management Functions
function showRecurringAllocationsModal() {
    document.getElementById('recurringAllocationsModal').style.display = 'block';
    loadRecurringAllocations();
    populateSubcategoryDropdown();
}

function showAddRecurringAllocationModal() {
    document.getElementById('addRecurringAllocationModal').style.display = 'block';
    populateSubcategoryDropdown();
}

function showEditRecurringAllocationModal(allocationId, allocatedAmount, periodType) {
    document.getElementById('editRecurringAllocationId').value = allocationId;
    document.getElementById('editRecurringAllocationAmount').value = allocatedAmount;
    document.getElementById('editRecurringAllocationPeriodType').value = periodType || 'monthly';
    document.getElementById('editRecurringAllocationModal').style.display = 'block';
}

function populateSubcategoryDropdown() {
    const select = document.getElementById('recurringSubcategory');
    select.innerHTML = '<option value="">Select a subcategory</option>';
    
    categories.forEach(category => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category.name;
        
        category.subcategories.forEach(subcategory => {
            const option = document.createElement('option');
            option.value = subcategory.id;
            option.textContent = subcategory.name;
            optgroup.appendChild(option);
        });
        
        select.appendChild(optgroup);
    });
}

function loadRecurringAllocations() {
    fetch('/api/recurring-allocations', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => response.json())
    .then(data => {
        renderRecurringAllocations(data);
    })
    .catch(error => console.error('Error loading recurring allocations:', error));
}

function renderRecurringAllocations(allocations) {
    const container = document.getElementById('recurringAllocationsList');
    
    if (allocations.length === 0) {
        container.innerHTML = `
            <div class="no-recurring-allocations">
                <i class="fas fa-repeat"></i>
                <p>No recurring allocations set up</p>
                <p>Click "Add Recurring Allocation" to get started</p>
            </div>
        `;
        return;
    }
    
    const periodTypeLabels = {
        'monthly': 'Monthly',
        'quarterly': 'Quarterly',
        'yearly': 'Yearly',
        'custom': 'Custom'
    };
    
    container.innerHTML = allocations.map(allocation => `
        <div class="recurring-allocation-item">
            <div class="allocation-info">
                <div class="allocation-category">${allocation.category_name}</div>
                <div class="allocation-subcategory">${allocation.subcategory_name}</div>
                <div class="allocation-amount">${formatCurrency(allocation.allocated_amount, userCurrency)}</div>
                <div class="allocation-period-type">
                    <span class="period-type-badge period-type-${allocation.period_type}">
                        ${periodTypeLabels[allocation.period_type] || allocation.period_type}
                    </span>
                </div>
            </div>
            <div class="allocation-actions">
                <button class="btn btn-secondary" onclick="showEditRecurringAllocationModal(${allocation.id}, ${allocation.allocated_amount}, '${allocation.period_type}')" title="Edit">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-danger" onclick="deleteRecurringAllocation(${allocation.id})" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// Add event listeners for recurring allocation forms
document.addEventListener('DOMContentLoaded', function() {
    const addRecurringAllocationForm = document.getElementById('addRecurringAllocationForm');
    const editRecurringAllocationForm = document.getElementById('editRecurringAllocationForm');
    
    if (addRecurringAllocationForm) {
        addRecurringAllocationForm.addEventListener('submit', handleAddRecurringAllocation);
    }
    
    if (editRecurringAllocationForm) {
        editRecurringAllocationForm.addEventListener('submit', handleEditRecurringAllocation);
    }
});

function handleAddRecurringAllocation(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const data = {
        subcategory_id: parseInt(formData.get('subcategory_id')),
        allocated_amount: parseFloat(formData.get('allocated_amount')),
        period_type: formData.get('period_type') || 'monthly'
    };
    
    fetch('/api/recurring-allocations', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Recurring allocation added successfully!', 'success');
        closeModal('addRecurringAllocationModal');
        e.target.reset();
        loadRecurringAllocations();
    })
    .catch(error => {
        console.error('Error adding recurring allocation:', error);
        showNotification('Error adding recurring allocation. Please try again.', 'error');
    });
}

function handleEditRecurringAllocation(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const allocationId = formData.get('allocation_id');
    const data = {
        allocated_amount: parseFloat(formData.get('allocated_amount')),
        period_type: formData.get('period_type') || 'monthly'
    };
    
    fetch(`/api/recurring-allocations/${allocationId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Recurring allocation updated successfully!', 'success');
        closeModal('editRecurringAllocationModal');
        loadRecurringAllocations();
    })
    .catch(error => {
        console.error('Error updating recurring allocation:', error);
        showNotification('Error updating recurring allocation. Please try again.', 'error');
    });
}

function deleteRecurringAllocation(allocationId) {
    if (confirm('Are you sure you want to delete this recurring allocation? This will remove it from future budgets but not affect current allocations.')) {
        fetch(`/api/recurring-allocations/${allocationId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': 'Bearer ' + getToken()
            }
        })
        .then(response => response.json())
        .then(data => {
            showNotification('Recurring allocation deleted successfully!', 'success');
            loadRecurringAllocations();
            // Reload categories to update the recurring icon display
            loadCategories();
        })
        .catch(error => {
            console.error('Error deleting recurring allocation:', error);
            showNotification('Error deleting recurring allocation. Please try again.', 'error');
        });
    }
}

// Debug and cleanup functions removed from user interface
// These are available as API endpoints for admin use if needed

// Transaction Modal Functions (for floating button)
function openAddExpenseModal() {
    document.getElementById('modalTransactionDate').value = new Date().toISOString().split('T')[0];
    loadModalCategories();
    document.getElementById('addExpenseModal').style.display = 'block';
}

function loadModalCategories() {
    fetch('/api/categories/categories', {
        headers: {
            'Authorization': 'Bearer ' + getToken()
        }
    })
    .then(response => response.json())
    .then(categories => {
        const categorySelect = document.getElementById('modalCategory');
        if (categorySelect) {
            categorySelect.innerHTML = '<option value="">Select a category</option>';
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                option.dataset.subcategories = JSON.stringify(category.subcategories);
                categorySelect.appendChild(option);
            });
        }
    })
    .catch(error => console.error('Error loading categories:', error));
}

function loadModalSubcategories() {
    const categorySelect = document.getElementById('modalCategory');
    const subcategorySelect = document.getElementById('modalSubcategory');
    
    if (!categorySelect || !subcategorySelect) return;
    
    subcategorySelect.innerHTML = '<option value="">Select a subcategory</option>';
    
    const selectedCategory = categorySelect.options[categorySelect.selectedIndex];
    if (selectedCategory.value && selectedCategory.dataset.subcategories) {
        const subcategories = JSON.parse(selectedCategory.dataset.subcategories);
        subcategories.forEach(subcategory => {
            const option = document.createElement('option');
            option.value = subcategory.id;
            option.textContent = subcategory.name;
            subcategorySelect.appendChild(option);
        });
    }
}

// Setup form listener for transaction modal
document.addEventListener('DOMContentLoaded', function() {
    const addExpenseForm = document.getElementById('addExpenseForm');
    if (addExpenseForm) {
        addExpenseForm.addEventListener('submit', handleModalExpenseSubmit);
    }
});

function handleModalExpenseSubmit(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const data = {
        amount: parseFloat(formData.get('amount')),
        transaction_date: formData.get('transaction_date'),
        description: formData.get('description'),
        comment: formData.get('comment'),
        subcategory_id: parseInt(formData.get('subcategory'))
    };
    
    // Validation
    if (!data.amount || data.amount <= 0) {
        showNotification('Please enter a valid amount', 'error');
        return;
    }
    
    if (!data.transaction_date) {
        showNotification('Please select a transaction date', 'error');
        return;
    }
    
    if (!data.subcategory_id) {
        showNotification('Please select a subcategory', 'error');
        return;
    }
    
    // Show loading state
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
    submitBtn.disabled = true;
    
    // Make API call
    fetch('/api/transactions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(data => {
        showNotification('Transaction added successfully!', 'success');
        closeModal('addExpenseModal');
        // Reset form
        const form = document.getElementById('addExpenseForm');
        if (form) {
            form.reset();
            document.getElementById('modalTransactionDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('modalSubcategory').innerHTML = '<option value="">Select a subcategory</option>';
        }
        // Reload categories to update spent amounts
        loadCategories();
        // Dispatch event to refresh dashboard
        window.dispatchEvent(new CustomEvent('budgetDataChanged', {
            detail: { type: 'transaction_added' }
        }));
    })
    .catch(error => {
        console.error('Error adding transaction:', error);
        const errorMessage = error.error || error.message || 'Error adding transaction. Please try again.';
        showNotification(errorMessage, 'error');
    })
    .finally(() => {
        if (submitBtn) {
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
        }
    });
}
</script>
{% endblock %}


